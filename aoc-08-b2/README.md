# Day 8 (Part 2)
([AoC link](https://adventofcode.com/2023/day/8))
Here is my actual working solution for Part 2. It relies on a two-stage process consisting of the following:
1. Notice that, if there are T total L/R tokens on the direction tape and N nodes in the graph, then there are NT total states. In particular, given some starting position, if we run the simulation through a total of NT+1 states, then we are guaranteed to be in a loop (this follows swiftly from the pigeonhole principle). From there, we can backtrack until we find the state we are currently in again. The postfix starting after that determines the entire asymptotics of the orbit (e.g. the period and so on). By doing this for each given starting node we can obtain asymptotic orbits for each of them. During this phase, we can also check whether the desired end-state happens to occur in the first NT+1 states. If it does, we can simply terminate early.

2. If we didn't run across the end-state in the first NT+1 states, we can find it by analyzing the asymptotic orbits. To do this, start by flattening each asymptotic orbit into a sequence of times when it reached a valid end-node (in the code this is called a "z-history", and they are computed by `get_future` and truncated in `get_asymptotics`). Given two of these, we can take the least common multiple of their periods and find any overlapping times within that timeframe (which also determine all of their future times of coincidence). Repeat this procedure until we have incorporated every asymptotic orbit, then do a little math to find the first time where they all coincide. 

This last bit is quite inefficient (at least as I've written it), so this still takes over a minute to run on my local machine; it could probably be sped up if I knew some more number theory, since I suspect that a lot of the checks that I am performing are redundant for mathematical reasons currently beyond my comprehension. 

Still, the main reason that this is slow is that it is not really the intended solution to the problem at all. Rather, disappointingly, the "intended" route seems to involve analyzing the given input directly, which turns out to be *vastly nicer than you have any right to suspect based on the problem statement*. In particular, each starting point enters an orbit of length (say) L_i at time L_i, which also happens to be the first time that it is at a valid ending node. There is really no reason whatsoever to believe any of these coincidences should happen *a priori*; I find this a little frustrating, since one or more of them could easily have been included in the problem statement, and as it is, I feel kind of like I wasted my time on a comprehensive solution to a boring problem.